
> 索引的出现就是为了提高数据查询的效率，就像书的目录一样

# 索引常见模型

## 哈希表

哈希表是以 键 - 值(key - value)存储数据的结构，我们只要传入键，就可以了在 O(1) 时间内找到对应的值。

哈希的思路是：将值放在数组里，用一个哈希函数吧 key 换算成一个确定的位置，然后将 value 放在数组的这个位置。如果 key 经过哈希函数的计算之后产生了哈希冲突，则在数组的这个位置拉出一个链表，将 value 链接到这个列表上，

查询的步骤为：根据 key 获取数组的位置，然后遍历链表得到需要的值。

> 使用哈希表新增数据的时候非常快，但是顺序并不是有序的，因此哈希索引做区间查询的速度非常慢。

因此哈希表这种结构适用于 `等值查找` 的情况

## 有序数组

有序数组的数据就都是以顺序排序的方式存储，如果数据不存在重复的情况下，查找可以使用 `二分查找` ，时间复杂度为 `O(log(N))` 。 

有序数据对范围查找时的效率也很高，只需找到大于等于最小值的数，然后依次向右查找，直到第一个大于最大值的数为止。

虽然有序数组查询效率很高，但是其更新数据效率很差，如果在中间插入一个数据则需要移动后面所有的数据，所消耗的成本很高。

因此有序数组适用于 `静态存储引擎` ，存储一些不会有修改的数据。

## 搜索树

搜索树中二叉搜索树是常用的一种数据结构，其特点为 `每个节点的左儿子小于父节点，父节点又小于右儿子` 。它的查询复杂度为 `O(log(N))` ，为维持平衡二叉树的更新复杂度也为 `O(log(N))` 。

树有二叉也有多叉。多叉树的每个节点有多个儿子，儿子之间的大小保证从做到右递增。虽然二叉搜索树效率是最高的，但是大多数数据库存储不用二叉树，因为而相同数据大小，二叉树的树高是最多的，从而导致磁盘读取频率增加。为了查询尽少量读取磁盘，就必须让查询过程访问尽少量的数据块。那就应该使用 `N` 叉树，`N` 的取值取决于数据块的大小。

***

# innoDB的索引模型

innoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为组织索引表，innoDB使用 B+ 树索引模型，因此这些数据都是存在 B+ 树中的。每一个索引在 innoDB 中对应一颗 B+ 树。

假设有一张表

```sql
create table T(
	id int primary key,
  k int not null,
  name varchar(16),
  index(k)
) engine=innoDB;
```

[![mMAnS0.png](https://s2.ax1x.com/2019/08/18/mMAnS0.png)](https://imgchr.com/i/mMAnS0)

根据索引树叶子节点的内容，索引类型可分为主键索引和非主键索引。

主键索引的叶子节点内容是整行数据。在innoDB中，主键索引也被成为聚簇索引。

非主键索引的叶子节点内容是主键的值。在innoDB中，非主键索引也被成为非聚簇索引、二级索引。

## 主键索引和非主键索引查询的区别

如果查询语句为 `select * from T where id = 1;` 即使用主键索引进行查询，那么只需要查询ID这棵B+树。

如果查询语句为 `select * from T where k = 100;` 即使用非主键索引进行查询，则需要先搜索k这棵B+树，得到ID值为1，在到ID索引树中搜索一次，总共需要搜索两次，而这个过程也成为 `回表`。

> 非主键索引的查询需要多扫描一棵索引树，因此平常应该尽量使用主键查询。

## 索引维护的过程

B+树为了维护索引的有序性，在插入新值的时候会做必要的维护。如果索引的值是顺序的，那么维护起来就很方便，直接往后追加即可。如果索引是无序的，则会先找到插入的位置，然后逻辑上挪动后面的数据，空出位置。如果当前所在数据页满了，则需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为 `页分裂`。如果频繁出现页分裂，数据库的性能将会受到很大的影响。除此之外，页分裂操作还会影响 `数据的利用率`。原本在一个页中的数据，分到两个页中，整体的空间利用率会降低大约50%。

根据上述索引维护的原理，在一般场景下，表需要一个自增主键，主键自增满足顺序插入的场景，每插入一条新数据都是追加操作，不会挪动其他数据也不会发生页分裂。

> 主键长度越小，非主键索引的叶子节点就越小，非主键索引占用的空间也就越小。
>
> 如果一个表只有一个索引并且该索引是唯一索引，那么这个表的主键可以不是自增主键。

# MySQL常见索引类别

## 主键索引

主键索引是一种特殊的索引，为了唯一标记一行数据的差异，不允许为空。

## 普通索引

最基本的索引，没有什么其他的限制。

## 唯一索引

与普通索引类似，唯一不同之处是值不能相同，但是可以为空。

## 覆盖索引

一般使用非聚簇索引需要进行回表来从主键索引树中获取具体的数据。但是如果非聚簇索引树上已经包含有所查询的信息，则不需要再次进行回表操作，可直接获取数据。

例如有一张公民信息表，对 姓名 和 身份证做了联合索引
```sql
CREATE TABLE people(
  `id` int(11) NOT NULL,
  `name` varchar(32) DEFAULT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY (`id_card`, `name`)
) ENGINE=InnoDB
```

如果使用这条SQL `SELECT name FROM people WHERE id_card = 'xxxxxx';` 通过身份证来查询公民的姓名，一般来说先会从索引树上找到对应的主键ID，再回到主键索引树上查找并获取姓名。然而有了覆盖索引，在索引树上已经包含了姓名信息(name)，因此不再需要回表查整行记录，直接返回，减少语句的执行时间。

> 覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。


## 最左前缀原则

B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

在建立联合索引的时候，安排索引内的字段顺序有两个原则

1. 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的
2. 考虑索引占用的空间

在使用最左前缀原则时也有两个原则

1. mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式


```sql
CREATE TABLE people(
  `id` int(11) NOT NULL,
  `name` varchar(32) DEFAULT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY (`name`, `age`)
) ENGINE=InnoDB
```

`SELECT * FROM people where name = '李华';` 可以使用到 name 索引  
`SELECT * FROM people where name like '李%';` 可以使用到 name 索引  
`SELECT * FROM people where name like '%李%';` 不可以使用到 name 索引

## 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

例如上面的表有这样一个SQL `SELECT * FROM people where name like '李%' and age = 10;`

当不使用索引下推的时候，MySQL会先通过最左前缀原则找到以 `李` 开头的索引，然后通过一个个回表拿到完整数据再进行比对，如果 `age = 10` 则返回数据，不然则放弃。

而使用索引下推则在 联合索引树那就开始进行比对，如果 `age != 10` 则直接过滤，只有 `age = 10` 才进行回表拿到具体数据。