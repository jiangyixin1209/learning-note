# fork操作

## fork操作出现问题的原因

* 同步操作
* 与内存量息息相关： 内存越大， 耗时越长(和机器类型有关)， 可以通过latest_fork_usec(查看fork执行时间)

## 改善fork的方法

* 优先使用物理机或者高效支持fork操作的虚拟化技术
* 控制Redis实例最大可用内存： maxmemory
* 降低fork频率: 例如放宽AOF重写自动触发时机和不必要的全量复制
* 合理配置Linux内存分配策略：vm.overcommit_memory=1


0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。(如果设置为0则会阻塞主线程)

1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。  

2， 表示内核允许分配超过所有物理内存和交换空间总和的内存


# 子进程开销

* CPU
    * 开销: RDB和AOF文件生成，属于CPU密集型
    * 优化：不做CPU绑定，不和CPU密集型部署
* 内存
    * 开销：fork内存开销， copy-on-write的开销
    * 优化：echo never > /sys/kernel/mm/transparent_hugepage/enabled
* 硬盘
    * 开销: AOF和RDB文件写入，可以结合iostat， iotop分析
    * 优化
        * 不和高硬盘负载服务部署在一起： 存储服务， 消息队列等
        * 设置配置 no-appendfsync-on-rewrite = yes
        * 根据写入量决定磁盘类型
        * 单机多部署实例持久化文件目录可以考虑分盘

# AOF追加阻塞

![2018-01-27_121044.jpg](https://i.loli.net/2018/01/28/5a6d3613dbf40.jpg)