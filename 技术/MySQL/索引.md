
> 索引的出现就是为了提高数据查询的效率，就像书的目录一样

# 索引常见模型

## 哈希表

哈希表是以 键 - 值(key - value)存储数据的结构，我们只要传入键，就可以了在 O(1) 时间内找到对应的值。

哈希的思路是：将值放在数组里，用一个哈希函数吧 key 换算成一个确定的位置，然后将 value 放在数组的这个位置。如果 key 经过哈希函数的计算之后产生了哈希冲突，则在数组的这个位置拉出一个链表，将 value 链接到这个列表上，

查询的步骤为：根据 key 获取数组的位置，然后遍历链表得到需要的值。

> 使用哈希表新增数据的时候非常快，但是顺序并不是有序的，因此哈希索引做区间查询的速度非常慢。

因此哈希表这种结构适用于 `等值查找` 的情况

## 有序数组

有序数组的数据就都是以顺序排序的方式存储，如果数据不存在重复的情况下，查找可以使用 `二分查找` ，时间复杂度为 `O(log(N))` 。 

有序数据对范围查找时的效率也很高，只需找到大于等于最小值的数，然后依次向右查找，直到第一个大于最大值的数为止。

虽然有序数组查询效率很高，但是其更新数据效率很差，如果在中间插入一个数据则需要移动后面所有的数据，所消耗的成本很高。

因此有序数组适用于 `静态存储引擎` ，存储一些不会有修改的数据。

## 搜索树

搜索树中二叉搜索树是常用的一种数据结构，其特点为 `每个节点的左儿子小于父节点，父节点又小于右儿子` 。它的查询复杂度为 `O(log(N))` ，为维持平衡二叉树的更新复杂度也为 `O(log(N))` 。

树有二叉也有多叉。多叉树的每个节点有多个儿子，儿子之间的大小保证从做到右递增。虽然二叉搜索树效率是最高的，但是大多数数据库存储不用二叉树，因为而相同数据大小，二叉树的树高是最多的，从而导致磁盘读取频率增加。为了查询尽少量读取磁盘，就必须让查询过程访问尽少量的数据块。那就应该使用 `N` 叉树，`N` 的取值取决于数据块的大小。

***

# innoDB的索引模型

innoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为组织索引表，innoDB使用 B+ 树索引模型，因此这些数据都是存在 B+ 树中的。每一个索引在 innoDB 中对应一颗 B+ 树。

假设有一张表

```sql
create table T(
	id int primary key,
  k int not null,
  name varchar(16),
  index(k)
) engine=innoDB;
```

[![mMAnS0.png](https://s2.ax1x.com/2019/08/18/mMAnS0.png)](https://imgchr.com/i/mMAnS0)

根据索引树叶子节点的内容，索引类型可分为主键索引和非主键索引。

主键索引的叶子节点内容是整行数据。在innoDB中，主键索引也被成为聚簇索引。

非主键索引的叶子节点内容是主键的值。在innoDB中，非主键索引也被成为非聚簇索引、二级索引。

## 主键索引和非主键索引查询的区别

如果查询语句为 `select * from T where id = 1;` 即使用主键索引进行查询，那么只需要查询ID这棵B+树。

如果查询语句为 `select * from T where k = 100;` 即使用非主键索引进行查询，则需要先搜索k这棵B+树，得到ID值为1，在到ID索引树中搜索一次，总共需要搜索两次，而这个过程也成为 `回表`。

> 非主键索引的查询需要多扫描一棵索引树，因此平常应该尽量使用主键查询。

## 索引维护的过程

B+树为了维护索引的有序性，在插入新值的时候会做必要的维护。如果索引的值是顺序的，那么维护起来就很方便，直接往后追加即可。如果索引是无序的，则会先找到插入的位置，然后逻辑上挪动后面的数据，空出位置。如果当前所在数据页满了，则需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为 `页分裂`。如果频繁出现页分裂，数据库的性能将会受到很大的影响。除此之外，页分裂操作还会影响 `数据的利用率`。原本在一个页中的数据，分到两个页中，整体的空间利用率会降低大约50%。

根据上述索引维护的原理，在一般场景下，表需要一个自增主键，主键自增满足顺序插入的场景，每插入一条新数据都是追加操作，不会挪动其他数据也不会发生页分裂。

> 主键长度越小，非主键索引的叶子节点就越小，非主键索引占用的空间也就越小。
>
> 如果一个表只有一个索引并且该索引是唯一索引，那么这个表的主键可以不是自增主键。

